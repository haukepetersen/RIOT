/*
 * Copyright (C) 2014 Hamburg University of Applied Sciences
 *               2016 Freie Universit√§t Berlin
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup     cpu_stm32f4
 * @{
 *
 * @file
 * @brief       Low-level SPI driver implementation
 *
 * @author      Peter Kietzmann <peter.kietzmann@haw-hamburg.de>
 * @author      Fabian Nack <nack@inf.fu-berlin.de>
 * @author      Hauke Petersen <hauke.petersen@fu-berlin.de>
 *
 * @}
 */

#include "cpu.h"
#include "mutex.h"
#include "assert.h"
#include "periph/spi.h"

#define ENABLE_DEBUG        (0)
#include "debug.h"

/* Remove this ugly guard once we selectively build the periph drivers */
#ifdef SPI_NUMOF

/**
 * @brief   Number of bits to shift the BR value in the CR1 register
 */
#define BR_SHIFT            (3U)

/**
 * @brief Array holding one pre-initialized mutex for each SPI device
 */
static mutex_t locks[SPI_NUMOF];

static inline SPI_TypeDef *dev(spi_t bus)
{
    return spi_config[bus].dev;
}

void spi_init(spi_t bus)
{
    assert(bus < SPI_NUMOF);

    /* initialize device lock */
    mutex_lock(&locks[bus]);
    /* trigger pin initialization */
    spi_init_pins(bus);
}

void spi_init_pins(spi_t bus)
{
    gpio_init(spi_config[bus].mosi_pin, GPIO_OUT);
    gpio_init(spi_config[bus].miso_pin, GPIO_IN);
    gpio_init(spi_config[bus].sclk_pin, GPIO_OUT);
    gpio_init_af(spi_config[bus].mosi_pin, spi_config[bus].af);
    gpio_init_af(spi_config[bus].miso_pin, spi_config[bus].af);
    gpio_init_af(spi_config[bus].sclk_pin, spi_config[bus].af);
}

int spi_init_cs(spi_t bus, spi_cs_t cs)
{
    if (bus >= SPI_NUMOF) {
        return SPI_NODEV;
    }
    if (cs == SPI_CS_UNDEF ||
        (((cs & SPI_HWCS_MASK) == SPI_HWCS_MASK) && (cs & ~(SPI_HWCS_MASK)))) {
        return SPI_NOCS;
    }

    if (cs == SPI_HWCS_MASK) {
        if (spi_config[bus].cs_pin == GPIO_UNDEF) {
            return SPI_NOCS;
        }
        gpio_init(spi_config[bus].cs_pin, GPIO_OUT);
        gpio_init_af(spi_config[bus].cs_pin, spi_config[bus].af);
    }
    else {
        gpio_init((gpio_t)cs, GPIO_OUT);
        gpio_set((gpio_t)cs);
    }

    return SPI_OK;
}

int spi_acquire(spi_t bus, spi_cs_t cs, spi_mode_t mode, spi_clk_t clk)
{
    assert((clk >= SPI_CLK_100KHZ) && (clk <= SPI_CLK_10MHZ));

    /* lock bus */
    mutex_lock(&locks[bus]);
    /* enable SPI device clock */
    periph_clk_en(spi_config[bus].apbbus, spi_config[bus].rccmask);
    /* configure clock and mode */
    uint8_t br = spi_divtable[spi_config[bus].apbbus][clk];
    dev(bus)->CR1 = ((br << 3) | mode | SPI_CR1_MSTR);
    if (cs != SPI_HWCS_MASK) {
        dev(bus)->CR1 |= (SPI_CR1_SSM | SPI_CR1_SSI);
    }

    return SPI_OK;
}

void spi_release(spi_t bus)
{
    /* disable device and release lock */
    dev(bus)->CR1 = 0;
    periph_clk_dis(spi_config[bus].apbbus, spi_config[bus].rccmask);
    mutex_unlock(&locks[bus]);
}

void spi_transfer_bytes(spi_t bus, spi_cs_t cs, bool cont,
                        const void *out, void *in, size_t len)
{
    uint8_t *inbuf = (uint8_t *)in;
    uint8_t *outbuf = (uint8_t *)out;

    /* make sure at least one input or one output buffer is given */
    assert(outbuf || inbuf);

    /* active the given chip select line */
    dev(bus)->CR1 |= (SPI_CR1_SPE);     /* this pulls the HW CS line low */
    if ((cs != SPI_HWCS_MASK) && (cs != SPI_CS_UNDEF)) {
        gpio_clear((gpio_t)cs);
    }

    /* transfer data, use shortpath if only sending data */
    if (!inbuf) {
        for (size_t i = 0; i < len; i++) {
            while (!(dev(bus)->SR & SPI_SR_TXE));
            dev(bus)->DR = outbuf[i];
        }
        /* wait until everything is finished and empty the receive buffer */
        while (dev(bus)->SR & SPI_SR_BSY) {}
        dev(bus)->DR;
    }
    else {
        for (size_t i = 0; i < len; i++) {
            uint8_t tmp = (outbuf) ? outbuf[i] : 0;
            while (!(dev(bus)->SR & SPI_SR_TXE));
            dev(bus)->DR = tmp;
            while (!(dev(bus)->SR & SPI_SR_RXNE));
            inbuf[i] = dev(bus)->DR;
        }
    }

    /* release the chip select if not specified differently */
    if ((!cont) && (cs != SPI_CS_UNDEF)) {
        dev(bus)->CR1 &= ~(SPI_CR1_SPE);    /* pull HW CS line high */
        if (cs != SPI_HWCS_MASK) {
            gpio_set((gpio_t)cs);
        }
    }
}

#endif /* SPI_NUMOF */
